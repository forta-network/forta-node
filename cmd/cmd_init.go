package cmd

import (
	"bytes"
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/fatih/color"
	"github.com/forta-protocol/forta-node/config"
	"github.com/spf13/cobra"
)

func handleFortaInit(cmd *cobra.Command, args []string) error {
	if isInitialized() {
		greenBold("Already initialized - please ensure that your configuration at %s is correct!\n", cfg.ConfigFilePath())
		return nil
	}

	if !isDirInitialized() {
		if err := os.Mkdir(cfg.FortaDir, 0755); err != nil {
			return err
		}
	}

	if !isConfigFileInitialized() {
		tmpl, err := template.New("config-template").Parse(defaultConfig)
		if err != nil {
			return err
		}
		var buf bytes.Buffer
		if err := tmpl.Execute(&buf, config.GetEnvDefaults(cfg.Development)); err != nil {
			return err
		}
		if err := os.WriteFile(cfg.ConfigFilePath(), buf.Bytes(), 0644); err != nil {
			return err
		}
	}

	if !isKeyDirInitialized() {
		if err := os.Mkdir(cfg.KeyDirPath, 0755); err != nil {
			return err
		}
	}

	if !isKeyInitialized() {
		if len(cfg.Passphrase) == 0 {
			yellowBold("Please provide a passphrase and do not lose it.\n\n")
			return cmd.Help()
		}

		ks := keystore.NewKeyStore(cfg.KeyDirPath, keystore.StandardScryptN, keystore.StandardScryptP)
		acct, err := ks.NewAccount(cfg.Passphrase)
		if err != nil {
			return err
		}
		printScannerAddress(acct.Address.Hex())
	}

	color.Green("\nSuccessfully initialized at %s\n", cfg.FortaDir)
	whiteBold("\n%s\n", strings.Join([]string{
		"- Please make sure that all of the values in config.yml are set correctly.",
		"- Please fund your scanner address with some MATIC.",
		"- Please enable it for the chain ID in your config by doing 'forta register --owner-address <your_owner_wallet_address>'.",
		"- Please also ensure that your scanner address satisifies FORT token staking minimum requirement.",
	}, "\n"))

	return nil
}

func printScannerAddress(address string) {
	fmt.Printf("\nScanner address: %s\n", color.New(color.FgYellow).Sprintf(address))
}

const defaultConfig = `# Auto generated by 'forta init' - safe to modify
# The chainId is the chainId of the network that is analyzed (1=mainnet)
chainId: 1

# The scan settings are used to retrieve the transactions that are analyzed
scan:
  jsonRpc:
    url: <required>

# The trace endpoint must support trace_block (such as alchemy)
trace:
  jsonRpc:
    url: <required>

# The registry settings are used to discover and load agents
# registry:
#  jsonRpc:
#    url: https://polygon-rpc.com/
#  ipfs:
#    gatewayUrl: https://ipfs.forta.network
#    username: <set if needed>
#    password: <set if needed>

# The jsonRpcProxy settings are used make query requests (defaults to scan url)
# jsonRpcProxy:
#   jsonRpc:
#     url: <enter if different from scan value>

# The publish settings drive how alerts are sent
# publish:
#  ipfs:
#    apiUrl: https://ipfs.forta.network
#    username: <set if needed>
#    password: <set if needed>

# The log settings drive the log output of the scan node
# log:
#  level: info
#  maxLogSize: 50m
#  maxLogFiles: 10
`

func isDirInitialized() bool {
	info, err := os.Stat(cfg.FortaDir)
	if err != nil {
		return false
	}
	return info.IsDir()
}

func isConfigFileInitialized() bool {
	info, err := os.Stat(cfg.ConfigFilePath())
	if err != nil {
		return false
	}
	return !info.IsDir()
}

func isKeyDirInitialized() bool {
	info, err := os.Stat(cfg.KeyDirPath)
	if err != nil {
		return false
	}
	return info.IsDir()
}

func isKeyInitialized() bool {
	if !isKeyDirInitialized() {
		return false
	}
	entries, err := os.ReadDir(cfg.KeyDirPath)
	if err != nil {
		return false
	}
	for i, entry := range entries {
		if i > 0 {
			return false // There must be one key file
		}
		return !entry.IsDir() // so it should be a geth key file
	}
	return false // No keys found in dir
}

func isInitialized() bool {
	return isDirInitialized() && isConfigFileInitialized() && isKeyInitialized()
}
